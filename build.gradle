/*
    NOTE TO MAINTAINERS:

    You should not need to change this file to configure your specific
    action image.  Image specific configurations occur in:

        ./docker-local.gradle -- for secrets/configurations that should NOT
            be uploaded to GitHub for the world to see
        ./settings.grade -- for listing the projects (and imageNames) to build
        ./.../build.grade -- for subproject-specific configurations

    Note:  The writing is on the wall that as other project builds come into
           play this module may need to move, perhaps to core/build.gradle or
           to an included directory.  But we shall persevere for the time
           being in keeping it here where it's obvious that a lot is going on.
 */

buildscript {
    repositories {
        jcenter()
        mavenLocal()
        maven {
            url  "http://dl.bintray.com/jonpspri/gradle-plugins/"
        }
    }
    dependencies {
        classpath "cz.alenkacz:gradle-scalafmt:${gradle.scalafmt.version}"
        classpath 'org.ajoberstar:grgit:2.1.0'
        classpath 'com.bmuschko:gradle-docker-plugin:3.2.2'
        classpath 'com.xanophis:gradle-fatmanifest-plugin:0.0.5'
    }
}

import com.bmuschko.gradle.docker.DockerRegistryCredentials
import com.bmuschko.gradle.docker.tasks.DockerInfo
import com.bmuschko.gradle.docker.tasks.image.*

//  There are some serious naming mismatchees to be dealt with in v0.0.6 of gradle-fatmanifest-plugin :(
import com.s390x.gradle.multidocker.tasks.*

/*
    So you called a registry method without providing any registry
    credentials?  Shame on you!  This warning (which likely needs editing) will
    put you back on the straight and narrow.

    Located here in the code so it's available within all necessary blocks.
 */
private def warnNoRegistryCredentials() {
    logger.warning """
    |You are attempting a registry task without having provided registry
    |credentials.  Registry credentials should be provided in the
    |'./docker-local.gradle' file.  See './docker-local.gradle.sample' for
    |an example.  Meanwhile, this action does nothing.
    |""".stripMargin()
}

/*
    These two lists will hold the projects to be managed throughout the
    remainder of the process -- the 'top-level' builds and the individual
    architecture builds created beneath each of them.

    Note:  The lists could possible be created by re-constructing the project
    paths, which in a performance-oriented system I'd consider doing.  But
    the findAll based approach works for now, and provides flexibility if we
    add later capability to settings to gradle to select only certain builds
    for certain projects (more of a matrix)
 */
Collection<Project> buildProjects = subprojects.findAll { subproject ->
        gradle.dockerBuildProjects.containsKey(subproject.path)
    }

Collection<Project> individualArchProjects = buildProjects.collectMany { buildProject ->
        buildProject.subprojects.findAll() {
            gradle.architectures.containsKey(it.name)
        }
    }

/*
    Every project in ':core:* is some form of Docker build for the action image
    and is therefore assumed to need to be able to push a Manifest List for
    eventual publication.  This block activates the Docker and Manifest List
    plugins and configures them from information provided in the docker-local
    file.  Recall that the docker-local file was loaded in
    settings.gradle and applied as extension properties to the gradle object.

    The :core:* projects (parent projects) should all have been set up and
    logged in 'grade.dockerBuildProjects' (by settings.gradle), along with the
    image name for each.  This is where we pull that image name and configure it
    into the project.

    Why put it in a gradle extension property first?  Frankly, we don't want
    to wait for it to be set in a project-specific build.gradle, and we want
    to limit configuration to the project-specific build.gradle and to the
    settings.gradle.  This (root) build.gradle should rarely have to change.

    (Side note:  Maybe these need to be in a plugin or sub-file, but IMO that
    actually makes maintenance more difficult.)
 */

configure (buildProjects) {
    buildscript.repositories { jcenter() }

    logger.info ("Configuring subproject '${path}'")

    /*
        We only configure Manifest List processing if registryCredentials exist,
        because otherwise what's the point?
    */
    if (gradle?.registryCredentials) {
        apply plugin: 'com.s390x.gradle.multidocker'

        logger.debug "Applying registry credentials to ${it.path}"
        multidocker.registry('default',gradle.registryCredentials)
    }

    /*
        Retrieve project properties from the Map created in settings.gradle
        and apply to the projects.  Now the properties are available during
        configuration in the remainder of this script.
     */
    logger.info "Setting properties for ${path}"
    gradle.dockerBuildProjects[path].each { k,v -> ext.set(k,v) }
    ext.dockerRegistry = gradle.dockerRegistry
    logger.info "Project ${path} has dockerImageName of ${dockerImageName}"
}

/*
    Each architecture gets its own project sharing a project directory with the
    root project.  It's EXPECTED (but not required) for the local build scripts
    to override the build directory with architecture-specific build directories
    as needed, which will also ease maintenance of the source tree for docker
    builds.

    Notice that in the block, we ensure that parent tasks are dependent on
    the underlying architecture tasks.  That way, we can still
    './gradlew core:<image>:<task>' and all architectures will be built.
 */

configure (individualArchProjects) {
    buildscript.repositories { jcenter() }

    logger.info ("Configuring subproject '${path}'")

    //  Since this is an architecture-specific subproject, we can copy all the
    //  properties from the parent project to make our code more readable
    parent.ext.properties.each { k,v -> ext.set(k,v) }

    apply plugin: 'com.bmuschko.docker-remote-api'
    docker {
        /*
            Since we survived the findAll, we know this architecture exists,
            which means fewer guard clauses.  Hooray!
         */
        if (gradle.architectures[name]?.url) {
            // Don't overwrite a default if it was defined!
            url = gradle.architectures[name].url
        }
        if (gradle.architectures[name]?.certPath) {
            certPath = rootProject.file(gradle.architectures[name].certPath)
        }

        /*
            Yet another place to check whether registryCredentials were
            actually provided.  It could be simplified by providing meaningless
            defaults, but it's a bit clearer this way that there's a
            responsiblity for the runtime developer.
         */
        if (gradle?.registryCredentials) registryCredentials {
            url = gradle.registryCredentials.url
            username = gradle.registryCredentials.username
            password = gradle.registryCredentials.password
            email = gradle.registryCredentials.email
        }
    }

    task dockerInfo(type: DockerInfo) {
        onNext {
            logger.quiet "Docker Info retreived for project ${project.name}:"
            logger.quiet "  OSType = ${it.osType}"
            logger.quiet "  Architecture = ${it.architecture}"
            owner.ext.dockerInfo = it
        }
    }
    (parent.tasks.find() {it.name=='dockerInfo'} ?: parent.task('dockerInfo'))\
        .dependsOn dockerInfo

    task dockerBuildImage(type: DockerBuildImage) {
        /*
            Recommended default for inputDir
         */
        inputDir = file("${project.projectDir}/build/docker/${project.name}")

        /*
            The tags list is out of hand and is doing a bang-up job of making
            my local docker repository messy.  However, I haven't really
            gotten a handle on what's needed and what's not.  For example,
            the dockerRegistry tag should probably be conditional.  The
            prefixed tag seems critical, however, to working with local-build
            openwhisk deployments.
         */

        //  Is this an appropriate prefix?  Perhaps we should use 'whisk' as the
        //  default local-build prefix?  Again -- not sure I have a sense of tags.
        def prefix = findProperty('dockerImagePrefix') ?: 'openwhisk'
        def tag = findProperty('dockerImageTag') ?: 'latest'

        //  Note that project.name will be the docker engine name from settings.gradle
        //  We could set up an option to declare suffixes in docker.gradle, but so far
        //  this works.
        tags = [   // Return a list of tags build from the environment
                "${parent.dockerImageName}:${tag}",
                "${parent.dockerImageName}:${tag}-${project.name}",
                "${prefix}/${parent.dockerImageName}:${tag}-${project.name}"
        ] as String[]

        //  This tag is created to support uploads if there's a target registry.
        //  Note that the script DOES NOT support multiple target registries.
        //  As of the writing, there was no need to.
        if (dockerRegistry) {
            tags += new String("${dockerRegistry}/${prefix}/"+
                "${parent.dockerImageName}:${tag}-${project.name}")
        }
    }
    (parent.tasks.find() {it.name=='dockerBuildImage'} ?: parent.task('dockerBuildImage'))\
        .dependsOn dockerBuildImage

    /*
        Pushing images and getting manifests only makes sense if registry
        credentials were provided, we we make this block conditional.  If
        no credentials were provided, the tasks will instead display a warning
        and point to a tutorial on docker-local.gradle.
     */
    if (gradle?.registryCredentials) {
        task dockerPushImage(type: DockerPushImage, dependsOn: dockerBuildImage) {
            imageName = "${dockerRegistry}/" +
                "${findProperty('dockerImagePrefix') ?: 'openwhisk'}/" +
                "${parent.dockerImageName}"
            tag = "${findProperty('dockerImageTag') ?: 'latest'}-${project.name}"
        }
        (parent.tasks.find() {it.name=='dockerPushImage'} ?: parent.task('dockerPushImage'))\
            .dependsOn dockerPushImage

        task getImageManifest(type: GetImageManifest, dependsOn: [ dockerPushImage, dockerInfo ] ) {

            targetRegistry = 'default'

            imageName =
                "${findProperty('dockerImagePrefix') ?: 'openwhisk'}/${parent.dockerImageName}"
            tag = "${findProperty('dockerImageTag') ?: 'latest'}-${project.name}"

            //  Store the relevant details of the received manifest as an
            //  extension of the task.
            onNext {
                logger.quiet "Manifest retreived for ${imageName}:${tag}"
                logger.quiet "  Digest: ${it.digest}"
                logger.quiet "  Media Type: ${it.mediaType}"
                logger.quiet "  Size: ${it.size}"

                owner.ext.manifestMap = [
                    mediaType: it.mediaType,
                    digest: it.digest,
                    size: it.size,
                    os: project.dockerInfo.dockerInfo.osType,
                    architecture: project.dockerInfo.dockerInfo.architecture
                ]
            }
        }
        (parent.tasks.find() {it.name=='getImageManifest'} ?: parent.task('getImageManifest'))\
            .dependsOn getImageManifest
    } else {
        task dockerPushImage() { warnNoRegistryCredentials() }
        task getImageManifest() { warnNoRegistryCredentials() }
    }
}

/*
    And now, the Manifest List.  It's a multi-architecture manifest, so there's
    no point to putting it in the individual architecture builds.  Instead, it
    will collect the individual manifests from the getManifest steps.
 */
configure (buildProjects) {
    if (gradle?.registryCredentials) {
        task putManifestList(type: PutManifestList, dependsOn: 'getImageManifest') {

            targetRegistry = 'default'

            imageName = "${findProperty('dockerImagePrefix') ?: 'openwhisk'}/" +
                "${project.dockerImageName}"
            // TODO - Project property candidate to support release builds?
            tag = "${findProperty('dockerImageTag') ?: 'latest' }"

            /*
                Collect the manifests to be built from the subprojects
             */
            project.subprojects.collectMany { subproject ->
                subproject.tasks.withType(GetImageManifest)
            }.each { task ->
                logger.info "Adding manifest ${it.path} to Manifest List"
                manifests << { task.manifestMap }
            }
        }
    } else {
        task putManifestList() { warnNoRegistryCredentials() }
    }
}

subprojects {
    apply plugin: 'scalafmt'
    scalafmt.configFilePath = gradle.scalafmt.config
}
